# 338. Counting Bits

## 題目

---

Given an integer `n`, return *an array* `ans` *of length* `n + 1` *such that for each* `i` **(`0 <= i <= n`)*,* `ans[i]` *is the **number of*** `1`***'s** in the binary representation of* `i`.

**Example 1:**

```
Input: n = 2
Output: [0,1,1]
Explanation:
0 --> 0
1 --> 1
2 --> 10

```

**Example 2:**

```
Input: n = 5
Output: [0,1,1,2,1,2]
Explanation:
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101

```

**Constraints:**

- `0 <= n <= 10^5`

**Follow up:**

- It is very easy to come up with a solution with a runtime of `O(n log n)`. Can you do it in linear time `O(n)` and possibly in a single pass?
- Can you do it without using any built-in function (i.e., like `__builtin_popcount` in C++)?

## 思路

---

## Code

---

- GoLang
    
    ```go
    func countBits(n int) []int {
        result := make([]int, n + 1)
        result[0] = 0
    
        power := 1
        
        i := 0
        
        for  {
            if i + power > n {
                break
            }
            if i + power < power * 2 {
                result[i + power] = 1 + result[i]
                i++
            } else {
                power = power * 2
                i = 0
            }       
        }
    
        return result
    }
    ```
    

## Reference

---